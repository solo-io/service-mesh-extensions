// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/registry.proto

package hub_solo_io

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MeshType int32

const (
	MeshType_ISTIO        MeshType = 0
	MeshType_LINKERD      MeshType = 1
	MeshType_AWS_APP_MESH MeshType = 2
)

var MeshType_name = map[int32]string{
	0: "ISTIO",
	1: "LINKERD",
	2: "AWS_APP_MESH",
}

var MeshType_value = map[string]int32{
	"ISTIO":        0,
	"LINKERD":      1,
	"AWS_APP_MESH": 2,
}

func (x MeshType) String() string {
	return proto.EnumName(MeshType_name, int32(x))
}

func (MeshType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{0}
}

// This is static content for an application. It includes basic metadata that is common to every version of an
// application, and a list of versions. For each version, there is information about how to install the application
// (for example, a Helm chart location), and the requirements for installation.
type ApplicationSpec struct {
	Name                  string                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	LogoUrl               string                      `protobuf:"bytes,3,opt,name=logo_url,json=logoUrl,proto3" json:"logo_url,omitempty"`
	ShortDescription      string                      `protobuf:"bytes,4,opt,name=short_description,json=shortDescription,proto3" json:"short_description,omitempty"`
	LongDescription       string                      `protobuf:"bytes,5,opt,name=long_description,json=longDescription,proto3" json:"long_description,omitempty"`
	DocumentationUrl      string                      `protobuf:"bytes,6,opt,name=documentation_url,json=documentationUrl,proto3" json:"documentation_url,omitempty"`
	RepositoryUrl         string                      `protobuf:"bytes,7,opt,name=repository_url,json=repositoryUrl,proto3" json:"repository_url,omitempty"`
	ApplicationCreator    string                      `protobuf:"bytes,8,opt,name=application_creator,json=applicationCreator,proto3" json:"application_creator,omitempty"`
	ApplicationProvider   string                      `protobuf:"bytes,9,opt,name=application_provider,json=applicationProvider,proto3" json:"application_provider,omitempty"`
	ApplicationMaintainer string                      `protobuf:"bytes,10,opt,name=application_maintainer,json=applicationMaintainer,proto3" json:"application_maintainer,omitempty"`
	DateCreated           *time.Time                  `protobuf:"bytes,11,opt,name=date_created,json=dateCreated,proto3,stdtime" json:"date_created,omitempty"`
	Versions              []*VersionedApplicationSpec `protobuf:"bytes,12,rep,name=versions,proto3" json:"versions,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                    `json:"-"`
	XXX_unrecognized      []byte                      `json:"-"`
	XXX_sizecache         int32                       `json:"-"`
}

func (m *ApplicationSpec) Reset()         { *m = ApplicationSpec{} }
func (m *ApplicationSpec) String() string { return proto.CompactTextString(m) }
func (*ApplicationSpec) ProtoMessage()    {}
func (*ApplicationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{0}
}
func (m *ApplicationSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationSpec.Unmarshal(m, b)
}
func (m *ApplicationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationSpec.Marshal(b, m, deterministic)
}
func (m *ApplicationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationSpec.Merge(m, src)
}
func (m *ApplicationSpec) XXX_Size() int {
	return xxx_messageInfo_ApplicationSpec.Size(m)
}
func (m *ApplicationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationSpec proto.InternalMessageInfo

func (m *ApplicationSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApplicationSpec) GetLogoUrl() string {
	if m != nil {
		return m.LogoUrl
	}
	return ""
}

func (m *ApplicationSpec) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *ApplicationSpec) GetLongDescription() string {
	if m != nil {
		return m.LongDescription
	}
	return ""
}

func (m *ApplicationSpec) GetDocumentationUrl() string {
	if m != nil {
		return m.DocumentationUrl
	}
	return ""
}

func (m *ApplicationSpec) GetRepositoryUrl() string {
	if m != nil {
		return m.RepositoryUrl
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationCreator() string {
	if m != nil {
		return m.ApplicationCreator
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationProvider() string {
	if m != nil {
		return m.ApplicationProvider
	}
	return ""
}

func (m *ApplicationSpec) GetApplicationMaintainer() string {
	if m != nil {
		return m.ApplicationMaintainer
	}
	return ""
}

func (m *ApplicationSpec) GetDateCreated() *time.Time {
	if m != nil {
		return m.DateCreated
	}
	return nil
}

func (m *ApplicationSpec) GetVersions() []*VersionedApplicationSpec {
	if m != nil {
		return m.Versions
	}
	return nil
}

// Represents a specific version of an extension.
type VersionedApplicationSpec struct {
	// The version of the application
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The date this version of the application was published
	DatePublished *time.Time `protobuf:"bytes,2,opt,name=date_published,json=datePublished,proto3,stdtime" json:"date_published,omitempty"`
	// Location of the Helm chart that will be used to install this application
	//
	// Types that are valid to be assigned to InstallationSpec:
	//	*VersionedApplicationSpec_GithubChart
	//	*VersionedApplicationSpec_HelmArchive
	//	*VersionedApplicationSpec_ManifestsArchive
	InstallationSpec isVersionedApplicationSpec_InstallationSpec `protobuf_oneof:"installation_spec"`
	// Optional default values yaml; if none provided, chart default will be used
	ValuesYaml string `protobuf:"bytes,30,opt,name=values_yaml,json=valuesYaml,proto3" json:"values_yaml,omitempty"`
	// Optional filter on the resources that should be considered part of the install, to handle cases
	// where a single chart can be used to deploy many applications (i.e. Istio chart deploys Kiali)
	RequiredLabels map[string]string `protobuf:"bytes,31,rep,name=required_labels,json=requiredLabels,proto3" json:"required_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Mesh-specific modifications to the extension installation manifest.
	Flavors              []*Flavor `protobuf:"bytes,40,rep,name=flavors,proto3" json:"flavors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VersionedApplicationSpec) Reset()         { *m = VersionedApplicationSpec{} }
func (m *VersionedApplicationSpec) String() string { return proto.CompactTextString(m) }
func (*VersionedApplicationSpec) ProtoMessage()    {}
func (*VersionedApplicationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{1}
}
func (m *VersionedApplicationSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionedApplicationSpec.Unmarshal(m, b)
}
func (m *VersionedApplicationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionedApplicationSpec.Marshal(b, m, deterministic)
}
func (m *VersionedApplicationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedApplicationSpec.Merge(m, src)
}
func (m *VersionedApplicationSpec) XXX_Size() int {
	return xxx_messageInfo_VersionedApplicationSpec.Size(m)
}
func (m *VersionedApplicationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedApplicationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedApplicationSpec proto.InternalMessageInfo

type isVersionedApplicationSpec_InstallationSpec interface {
	isVersionedApplicationSpec_InstallationSpec()
	Equal(interface{}) bool
}

type VersionedApplicationSpec_GithubChart struct {
	GithubChart *GithubRepositoryLocation `protobuf:"bytes,13,opt,name=github_chart,json=githubChart,proto3,oneof"`
}
type VersionedApplicationSpec_HelmArchive struct {
	HelmArchive *TgzLocation `protobuf:"bytes,14,opt,name=helm_archive,json=helmArchive,proto3,oneof"`
}
type VersionedApplicationSpec_ManifestsArchive struct {
	ManifestsArchive *TgzLocation `protobuf:"bytes,15,opt,name=manifests_archive,json=manifestsArchive,proto3,oneof"`
}

func (*VersionedApplicationSpec_GithubChart) isVersionedApplicationSpec_InstallationSpec()      {}
func (*VersionedApplicationSpec_HelmArchive) isVersionedApplicationSpec_InstallationSpec()      {}
func (*VersionedApplicationSpec_ManifestsArchive) isVersionedApplicationSpec_InstallationSpec() {}

func (m *VersionedApplicationSpec) GetInstallationSpec() isVersionedApplicationSpec_InstallationSpec {
	if m != nil {
		return m.InstallationSpec
	}
	return nil
}

func (m *VersionedApplicationSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VersionedApplicationSpec) GetDatePublished() *time.Time {
	if m != nil {
		return m.DatePublished
	}
	return nil
}

func (m *VersionedApplicationSpec) GetGithubChart() *GithubRepositoryLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_GithubChart); ok {
		return x.GithubChart
	}
	return nil
}

func (m *VersionedApplicationSpec) GetHelmArchive() *TgzLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_HelmArchive); ok {
		return x.HelmArchive
	}
	return nil
}

func (m *VersionedApplicationSpec) GetManifestsArchive() *TgzLocation {
	if x, ok := m.GetInstallationSpec().(*VersionedApplicationSpec_ManifestsArchive); ok {
		return x.ManifestsArchive
	}
	return nil
}

func (m *VersionedApplicationSpec) GetValuesYaml() string {
	if m != nil {
		return m.ValuesYaml
	}
	return ""
}

func (m *VersionedApplicationSpec) GetRequiredLabels() map[string]string {
	if m != nil {
		return m.RequiredLabels
	}
	return nil
}

func (m *VersionedApplicationSpec) GetFlavors() []*Flavor {
	if m != nil {
		return m.Flavors
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VersionedApplicationSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VersionedApplicationSpec_OneofMarshaler, _VersionedApplicationSpec_OneofUnmarshaler, _VersionedApplicationSpec_OneofSizer, []interface{}{
		(*VersionedApplicationSpec_GithubChart)(nil),
		(*VersionedApplicationSpec_HelmArchive)(nil),
		(*VersionedApplicationSpec_ManifestsArchive)(nil),
	}
}

func _VersionedApplicationSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VersionedApplicationSpec)
	// installation_spec
	switch x := m.InstallationSpec.(type) {
	case *VersionedApplicationSpec_GithubChart:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GithubChart); err != nil {
			return err
		}
	case *VersionedApplicationSpec_HelmArchive:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HelmArchive); err != nil {
			return err
		}
	case *VersionedApplicationSpec_ManifestsArchive:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ManifestsArchive); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VersionedApplicationSpec.InstallationSpec has unexpected type %T", x)
	}
	return nil
}

func _VersionedApplicationSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VersionedApplicationSpec)
	switch tag {
	case 13: // installation_spec.github_chart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubRepositoryLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_GithubChart{msg}
		return true, err
	case 14: // installation_spec.helm_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_HelmArchive{msg}
		return true, err
	case 15: // installation_spec.manifests_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.InstallationSpec = &VersionedApplicationSpec_ManifestsArchive{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VersionedApplicationSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VersionedApplicationSpec)
	// installation_spec
	switch x := m.InstallationSpec.(type) {
	case *VersionedApplicationSpec_GithubChart:
		s := proto.Size(x.GithubChart)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VersionedApplicationSpec_HelmArchive:
		s := proto.Size(x.HelmArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VersionedApplicationSpec_ManifestsArchive:
		s := proto.Size(x.ManifestsArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A flavor represents a particular variant of an extension.
type Flavor struct {
	// Identifier of the flavor
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field should contain a clear description of what this flavor is intended to accomplish.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Optional customizations that are to be applied to the installation manifest.
	CustomizationLayers []*Layer `protobuf:"bytes,3,rep,name=customization_layers,json=customizationLayers,proto3" json:"customization_layers,omitempty"`
	// The flavor is considered applicable if any of the specified requirement sets is satisfied.
	RequirementSets      []*RequirementSet `protobuf:"bytes,4,rep,name=requirement_sets,json=requirementSets,proto3" json:"requirement_sets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Flavor) Reset()         { *m = Flavor{} }
func (m *Flavor) String() string { return proto.CompactTextString(m) }
func (*Flavor) ProtoMessage()    {}
func (*Flavor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{2}
}
func (m *Flavor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Flavor.Unmarshal(m, b)
}
func (m *Flavor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Flavor.Marshal(b, m, deterministic)
}
func (m *Flavor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flavor.Merge(m, src)
}
func (m *Flavor) XXX_Size() int {
	return xxx_messageInfo_Flavor.Size(m)
}
func (m *Flavor) XXX_DiscardUnknown() {
	xxx_messageInfo_Flavor.DiscardUnknown(m)
}

var xxx_messageInfo_Flavor proto.InternalMessageInfo

func (m *Flavor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Flavor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Flavor) GetCustomizationLayers() []*Layer {
	if m != nil {
		return m.CustomizationLayers
	}
	return nil
}

func (m *Flavor) GetRequirementSets() []*RequirementSet {
	if m != nil {
		return m.RequirementSets
	}
	return nil
}

// A layer represent optional processing steps that can be executed to apply mesh-specific transformations to
// the rendered extension installation manifest.
type Layer struct {
	// The actual implementation of the layer
	//
	// Types that are valid to be assigned to Type:
	//	*Layer_Kustomize
	Type                 isLayer_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Layer) Reset()         { *m = Layer{} }
func (m *Layer) String() string { return proto.CompactTextString(m) }
func (*Layer) ProtoMessage()    {}
func (*Layer) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{3}
}
func (m *Layer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer.Unmarshal(m, b)
}
func (m *Layer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer.Marshal(b, m, deterministic)
}
func (m *Layer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer.Merge(m, src)
}
func (m *Layer) XXX_Size() int {
	return xxx_messageInfo_Layer.Size(m)
}
func (m *Layer) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer.DiscardUnknown(m)
}

var xxx_messageInfo_Layer proto.InternalMessageInfo

type isLayer_Type interface {
	isLayer_Type()
	Equal(interface{}) bool
}

type Layer_Kustomize struct {
	Kustomize *Kustomize `protobuf:"bytes,1,opt,name=kustomize,proto3,oneof"`
}

func (*Layer_Kustomize) isLayer_Type() {}

func (m *Layer) GetType() isLayer_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Layer) GetKustomize() *Kustomize {
	if x, ok := m.GetType().(*Layer_Kustomize); ok {
		return x.Kustomize
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Layer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Layer_OneofMarshaler, _Layer_OneofUnmarshaler, _Layer_OneofSizer, []interface{}{
		(*Layer_Kustomize)(nil),
	}
}

func _Layer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Layer)
	// type
	switch x := m.Type.(type) {
	case *Layer_Kustomize:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Kustomize); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Layer.Type has unexpected type %T", x)
	}
	return nil
}

func _Layer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Layer)
	switch tag {
	case 1: // type.kustomize
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Kustomize)
		err := b.DecodeMessage(msg)
		m.Type = &Layer_Kustomize{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Layer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Layer)
	// type
	switch x := m.Type.(type) {
	case *Layer_Kustomize:
		s := proto.Size(x.Kustomize)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a layer implemented via [kustomize](https://github.com/kubernetes-sigs/kustomize)
type Kustomize struct {
	// Location of the root of the kustomize directory structure
	//
	// Types that are valid to be assigned to Location:
	//	*Kustomize_Github
	//	*Kustomize_TgzArchive
	Location isKustomize_Location `protobuf_oneof:"location"`
	// Path to the overlay overlay that will be applied to the base (the rendered installation manifest).
	OverlayPath          string   `protobuf:"bytes,3,opt,name=overlay_path,json=overlayPath,proto3" json:"overlay_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kustomize) Reset()         { *m = Kustomize{} }
func (m *Kustomize) String() string { return proto.CompactTextString(m) }
func (*Kustomize) ProtoMessage()    {}
func (*Kustomize) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{4}
}
func (m *Kustomize) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kustomize.Unmarshal(m, b)
}
func (m *Kustomize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kustomize.Marshal(b, m, deterministic)
}
func (m *Kustomize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kustomize.Merge(m, src)
}
func (m *Kustomize) XXX_Size() int {
	return xxx_messageInfo_Kustomize.Size(m)
}
func (m *Kustomize) XXX_DiscardUnknown() {
	xxx_messageInfo_Kustomize.DiscardUnknown(m)
}

var xxx_messageInfo_Kustomize proto.InternalMessageInfo

type isKustomize_Location interface {
	isKustomize_Location()
	Equal(interface{}) bool
}

type Kustomize_Github struct {
	Github *GithubRepositoryLocation `protobuf:"bytes,1,opt,name=github,proto3,oneof"`
}
type Kustomize_TgzArchive struct {
	TgzArchive *TgzLocation `protobuf:"bytes,2,opt,name=tgz_archive,json=tgzArchive,proto3,oneof"`
}

func (*Kustomize_Github) isKustomize_Location()     {}
func (*Kustomize_TgzArchive) isKustomize_Location() {}

func (m *Kustomize) GetLocation() isKustomize_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Kustomize) GetGithub() *GithubRepositoryLocation {
	if x, ok := m.GetLocation().(*Kustomize_Github); ok {
		return x.Github
	}
	return nil
}

func (m *Kustomize) GetTgzArchive() *TgzLocation {
	if x, ok := m.GetLocation().(*Kustomize_TgzArchive); ok {
		return x.TgzArchive
	}
	return nil
}

func (m *Kustomize) GetOverlayPath() string {
	if m != nil {
		return m.OverlayPath
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Kustomize) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Kustomize_OneofMarshaler, _Kustomize_OneofUnmarshaler, _Kustomize_OneofSizer, []interface{}{
		(*Kustomize_Github)(nil),
		(*Kustomize_TgzArchive)(nil),
	}
}

func _Kustomize_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Kustomize)
	// location
	switch x := m.Location.(type) {
	case *Kustomize_Github:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Github); err != nil {
			return err
		}
	case *Kustomize_TgzArchive:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TgzArchive); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Kustomize.Location has unexpected type %T", x)
	}
	return nil
}

func _Kustomize_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Kustomize)
	switch tag {
	case 1: // location.github
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubRepositoryLocation)
		err := b.DecodeMessage(msg)
		m.Location = &Kustomize_Github{msg}
		return true, err
	case 2: // location.tgz_archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TgzLocation)
		err := b.DecodeMessage(msg)
		m.Location = &Kustomize_TgzArchive{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Kustomize_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Kustomize)
	// location
	switch x := m.Location.(type) {
	case *Kustomize_Github:
		s := proto.Size(x.Github)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Kustomize_TgzArchive:
		s := proto.Size(x.TgzArchive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Wraps a collection of FlavorCompatibilityInfo
type FlavorCompatibility struct {
	CompatiblePairs      []*CompatibleFlavorMeshPair `protobuf:"bytes,1,rep,name=compatible_pairs,json=compatiblePairs,proto3" json:"compatible_pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *FlavorCompatibility) Reset()         { *m = FlavorCompatibility{} }
func (m *FlavorCompatibility) String() string { return proto.CompactTextString(m) }
func (*FlavorCompatibility) ProtoMessage()    {}
func (*FlavorCompatibility) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{5}
}
func (m *FlavorCompatibility) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlavorCompatibility.Unmarshal(m, b)
}
func (m *FlavorCompatibility) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlavorCompatibility.Marshal(b, m, deterministic)
}
func (m *FlavorCompatibility) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorCompatibility.Merge(m, src)
}
func (m *FlavorCompatibility) XXX_Size() int {
	return xxx_messageInfo_FlavorCompatibility.Size(m)
}
func (m *FlavorCompatibility) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorCompatibility.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorCompatibility proto.InternalMessageInfo

func (m *FlavorCompatibility) GetCompatiblePairs() []*CompatibleFlavorMeshPair {
	if m != nil {
		return m.CompatiblePairs
	}
	return nil
}

type ResourceRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceRef) Reset()         { *m = ResourceRef{} }
func (m *ResourceRef) String() string { return proto.CompactTextString(m) }
func (*ResourceRef) ProtoMessage()    {}
func (*ResourceRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{6}
}
func (m *ResourceRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceRef.Unmarshal(m, b)
}
func (m *ResourceRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceRef.Marshal(b, m, deterministic)
}
func (m *ResourceRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceRef.Merge(m, src)
}
func (m *ResourceRef) XXX_Size() int {
	return xxx_messageInfo_ResourceRef.Size(m)
}
func (m *ResourceRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceRef.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceRef proto.InternalMessageInfo

func (m *ResourceRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceRef) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Represents a Flavor and a Mesh instance that are compatible with one another.
type CompatibleFlavorMeshPair struct {
	Flavor               *Flavor      `protobuf:"bytes,1,opt,name=flavor,proto3" json:"flavor,omitempty"`
	Mesh                 *ResourceRef `protobuf:"bytes,2,opt,name=mesh,proto3" json:"mesh,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CompatibleFlavorMeshPair) Reset()         { *m = CompatibleFlavorMeshPair{} }
func (m *CompatibleFlavorMeshPair) String() string { return proto.CompactTextString(m) }
func (*CompatibleFlavorMeshPair) ProtoMessage()    {}
func (*CompatibleFlavorMeshPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{7}
}
func (m *CompatibleFlavorMeshPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Unmarshal(m, b)
}
func (m *CompatibleFlavorMeshPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Marshal(b, m, deterministic)
}
func (m *CompatibleFlavorMeshPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompatibleFlavorMeshPair.Merge(m, src)
}
func (m *CompatibleFlavorMeshPair) XXX_Size() int {
	return xxx_messageInfo_CompatibleFlavorMeshPair.Size(m)
}
func (m *CompatibleFlavorMeshPair) XXX_DiscardUnknown() {
	xxx_messageInfo_CompatibleFlavorMeshPair.DiscardUnknown(m)
}

var xxx_messageInfo_CompatibleFlavorMeshPair proto.InternalMessageInfo

func (m *CompatibleFlavorMeshPair) GetFlavor() *Flavor {
	if m != nil {
		return m.Flavor
	}
	return nil
}

func (m *CompatibleFlavorMeshPair) GetMesh() *ResourceRef {
	if m != nil {
		return m.Mesh
	}
	return nil
}

// Represents a set of requirements that all need to be satisfied.
type RequirementSet struct {
	MeshRequirement      *MeshRequirement `protobuf:"bytes,1,opt,name=mesh_requirement,json=meshRequirement,proto3" json:"mesh_requirement,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RequirementSet) Reset()         { *m = RequirementSet{} }
func (m *RequirementSet) String() string { return proto.CompactTextString(m) }
func (*RequirementSet) ProtoMessage()    {}
func (*RequirementSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{8}
}
func (m *RequirementSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequirementSet.Unmarshal(m, b)
}
func (m *RequirementSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequirementSet.Marshal(b, m, deterministic)
}
func (m *RequirementSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequirementSet.Merge(m, src)
}
func (m *RequirementSet) XXX_Size() int {
	return xxx_messageInfo_RequirementSet.Size(m)
}
func (m *RequirementSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RequirementSet.DiscardUnknown(m)
}

var xxx_messageInfo_RequirementSet proto.InternalMessageInfo

func (m *RequirementSet) GetMeshRequirement() *MeshRequirement {
	if m != nil {
		return m.MeshRequirement
	}
	return nil
}

// Represents the requirement for a mesh to be installed.
type MeshRequirement struct {
	// Type of mesh
	MeshType MeshType `protobuf:"varint,1,opt,name=mesh_type,json=meshType,proto3,enum=hub.solo.io.MeshType" json:"mesh_type,omitempty"`
	// Range of allowed versions. If empty, any version is allowed.
	Versions             *AllowedVersions `protobuf:"bytes,2,opt,name=versions,proto3" json:"versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MeshRequirement) Reset()         { *m = MeshRequirement{} }
func (m *MeshRequirement) String() string { return proto.CompactTextString(m) }
func (*MeshRequirement) ProtoMessage()    {}
func (*MeshRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{9}
}
func (m *MeshRequirement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MeshRequirement.Unmarshal(m, b)
}
func (m *MeshRequirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MeshRequirement.Marshal(b, m, deterministic)
}
func (m *MeshRequirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshRequirement.Merge(m, src)
}
func (m *MeshRequirement) XXX_Size() int {
	return xxx_messageInfo_MeshRequirement.Size(m)
}
func (m *MeshRequirement) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshRequirement.DiscardUnknown(m)
}

var xxx_messageInfo_MeshRequirement proto.InternalMessageInfo

func (m *MeshRequirement) GetMeshType() MeshType {
	if m != nil {
		return m.MeshType
	}
	return MeshType_ISTIO
}

func (m *MeshRequirement) GetVersions() *AllowedVersions {
	if m != nil {
		return m.Versions
	}
	return nil
}

// A directory inside of a github repo
type GithubRepositoryLocation struct {
	Org                  string   `protobuf:"bytes,1,opt,name=org,proto3" json:"org,omitempty"`
	Repo                 string   `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Ref                  string   `protobuf:"bytes,3,opt,name=ref,proto3" json:"ref,omitempty"`
	Directory            string   `protobuf:"bytes,4,opt,name=directory,proto3" json:"directory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GithubRepositoryLocation) Reset()         { *m = GithubRepositoryLocation{} }
func (m *GithubRepositoryLocation) String() string { return proto.CompactTextString(m) }
func (*GithubRepositoryLocation) ProtoMessage()    {}
func (*GithubRepositoryLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{10}
}
func (m *GithubRepositoryLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GithubRepositoryLocation.Unmarshal(m, b)
}
func (m *GithubRepositoryLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GithubRepositoryLocation.Marshal(b, m, deterministic)
}
func (m *GithubRepositoryLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubRepositoryLocation.Merge(m, src)
}
func (m *GithubRepositoryLocation) XXX_Size() int {
	return xxx_messageInfo_GithubRepositoryLocation.Size(m)
}
func (m *GithubRepositoryLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubRepositoryLocation.DiscardUnknown(m)
}

var xxx_messageInfo_GithubRepositoryLocation proto.InternalMessageInfo

func (m *GithubRepositoryLocation) GetOrg() string {
	if m != nil {
		return m.Org
	}
	return ""
}

func (m *GithubRepositoryLocation) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *GithubRepositoryLocation) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *GithubRepositoryLocation) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

// Location of a gzipped tar file
type TgzLocation struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TgzLocation) Reset()         { *m = TgzLocation{} }
func (m *TgzLocation) String() string { return proto.CompactTextString(m) }
func (*TgzLocation) ProtoMessage()    {}
func (*TgzLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{11}
}
func (m *TgzLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TgzLocation.Unmarshal(m, b)
}
func (m *TgzLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TgzLocation.Marshal(b, m, deterministic)
}
func (m *TgzLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TgzLocation.Merge(m, src)
}
func (m *TgzLocation) XXX_Size() int {
	return xxx_messageInfo_TgzLocation.Size(m)
}
func (m *TgzLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_TgzLocation.DiscardUnknown(m)
}

var xxx_messageInfo_TgzLocation proto.InternalMessageInfo

func (m *TgzLocation) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type AllowedVersions struct {
	MinVersion           string   `protobuf:"bytes,2,opt,name=min_version,json=minVersion,proto3" json:"min_version,omitempty"`
	MaxVersion           string   `protobuf:"bytes,3,opt,name=max_version,json=maxVersion,proto3" json:"max_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllowedVersions) Reset()         { *m = AllowedVersions{} }
func (m *AllowedVersions) String() string { return proto.CompactTextString(m) }
func (*AllowedVersions) ProtoMessage()    {}
func (*AllowedVersions) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1ad3a89626d72ea, []int{12}
}
func (m *AllowedVersions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllowedVersions.Unmarshal(m, b)
}
func (m *AllowedVersions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllowedVersions.Marshal(b, m, deterministic)
}
func (m *AllowedVersions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedVersions.Merge(m, src)
}
func (m *AllowedVersions) XXX_Size() int {
	return xxx_messageInfo_AllowedVersions.Size(m)
}
func (m *AllowedVersions) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedVersions.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedVersions proto.InternalMessageInfo

func (m *AllowedVersions) GetMinVersion() string {
	if m != nil {
		return m.MinVersion
	}
	return ""
}

func (m *AllowedVersions) GetMaxVersion() string {
	if m != nil {
		return m.MaxVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("hub.solo.io.MeshType", MeshType_name, MeshType_value)
	proto.RegisterType((*ApplicationSpec)(nil), "hub.solo.io.ApplicationSpec")
	proto.RegisterType((*VersionedApplicationSpec)(nil), "hub.solo.io.VersionedApplicationSpec")
	proto.RegisterMapType((map[string]string)(nil), "hub.solo.io.VersionedApplicationSpec.RequiredLabelsEntry")
	proto.RegisterType((*Flavor)(nil), "hub.solo.io.Flavor")
	proto.RegisterType((*Layer)(nil), "hub.solo.io.Layer")
	proto.RegisterType((*Kustomize)(nil), "hub.solo.io.Kustomize")
	proto.RegisterType((*FlavorCompatibility)(nil), "hub.solo.io.FlavorCompatibility")
	proto.RegisterType((*ResourceRef)(nil), "hub.solo.io.ResourceRef")
	proto.RegisterType((*CompatibleFlavorMeshPair)(nil), "hub.solo.io.CompatibleFlavorMeshPair")
	proto.RegisterType((*RequirementSet)(nil), "hub.solo.io.RequirementSet")
	proto.RegisterType((*MeshRequirement)(nil), "hub.solo.io.MeshRequirement")
	proto.RegisterType((*GithubRepositoryLocation)(nil), "hub.solo.io.GithubRepositoryLocation")
	proto.RegisterType((*TgzLocation)(nil), "hub.solo.io.TgzLocation")
	proto.RegisterType((*AllowedVersions)(nil), "hub.solo.io.AllowedVersions")
}

func init() { proto.RegisterFile("api/v1/registry.proto", fileDescriptor_d1ad3a89626d72ea) }

var fileDescriptor_d1ad3a89626d72ea = []byte{
	// 1115 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xeb, 0x6e, 0x1b, 0x45,
	0x14, 0xae, 0x13, 0xe7, 0xe2, 0xb3, 0x69, 0xec, 0x4c, 0xd2, 0x6a, 0x09, 0x55, 0x13, 0x56, 0xaa,
	0x14, 0x28, 0x38, 0x6a, 0xb8, 0xa8, 0x80, 0x50, 0xe5, 0xa4, 0x69, 0x5a, 0x9a, 0x82, 0xb5, 0x0e,
	0xa0, 0xfe, 0x5a, 0x8d, 0xd7, 0x93, 0xf5, 0xa8, 0xb3, 0x3b, 0xcb, 0xcc, 0xac, 0xa9, 0xf3, 0x87,
	0x47, 0x80, 0xc7, 0xe0, 0x11, 0x78, 0x09, 0x1e, 0x01, 0x21, 0xf1, 0x24, 0x68, 0x2e, 0x6b, 0xef,
	0x16, 0x57, 0xcd, 0x2f, 0xcf, 0x9c, 0xf3, 0x7d, 0xdf, 0x5c, 0xce, 0xb7, 0x67, 0x0c, 0xb7, 0x70,
	0x4e, 0x0f, 0x27, 0x0f, 0x0e, 0x05, 0x49, 0xa8, 0x54, 0x62, 0xda, 0xcd, 0x05, 0x57, 0x1c, 0x79,
	0xe3, 0x62, 0xd8, 0x95, 0x9c, 0xf1, 0x2e, 0xe5, 0xbb, 0x3b, 0x09, 0x4f, 0xb8, 0x89, 0x1f, 0xea,
	0x91, 0x85, 0xec, 0xee, 0x25, 0x9c, 0x27, 0x8c, 0x1c, 0x9a, 0xd9, 0xb0, 0xb8, 0x3c, 0x54, 0x34,
	0x25, 0x52, 0xe1, 0x34, 0xb7, 0x80, 0xe0, 0xb7, 0x26, 0xb4, 0x7b, 0x79, 0xce, 0x68, 0x8c, 0x15,
	0xe5, 0xd9, 0x20, 0x27, 0x31, 0x42, 0xd0, 0xcc, 0x70, 0x4a, 0xfc, 0xa5, 0xfd, 0xc6, 0x41, 0x2b,
	0x34, 0x63, 0xf4, 0x1e, 0xac, 0x33, 0x9e, 0xf0, 0xa8, 0x10, 0xcc, 0x5f, 0x36, 0xf1, 0x35, 0x3d,
	0xff, 0x41, 0x30, 0x74, 0x1f, 0xb6, 0xe4, 0x98, 0x0b, 0x15, 0x8d, 0x88, 0x8c, 0x05, 0xcd, 0xb5,
	0x8e, 0xdf, 0x34, 0x98, 0x8e, 0x49, 0x3c, 0x9e, 0xc7, 0xd1, 0x87, 0xd0, 0x61, 0x3c, 0x4b, 0x6a,
	0xd8, 0x15, 0x83, 0x6d, 0xeb, 0x78, 0x15, 0x7a, 0x1f, 0xb6, 0x46, 0x3c, 0x2e, 0x52, 0x92, 0x29,
	0xb3, 0x37, 0xb3, 0xf6, 0xaa, 0xd5, 0xad, 0x25, 0xf4, 0x26, 0xee, 0xc1, 0xa6, 0x20, 0x39, 0x97,
	0x54, 0x71, 0x31, 0x35, 0xc8, 0x35, 0x83, 0xbc, 0x39, 0x8f, 0x6a, 0xd8, 0x21, 0x6c, 0xe3, 0xf9,
	0x69, 0xa3, 0x58, 0x10, 0xac, 0xb8, 0xf0, 0xd7, 0x0d, 0x16, 0x55, 0x52, 0x27, 0x36, 0x83, 0x1e,
	0xc0, 0x4e, 0x95, 0x90, 0x0b, 0x3e, 0xa1, 0x23, 0x22, 0xfc, 0x96, 0x61, 0x54, 0xc5, 0xfa, 0x2e,
	0x85, 0x3e, 0x87, 0xdb, 0x55, 0x4a, 0x8a, 0x69, 0xa6, 0x30, 0xcd, 0x88, 0xf0, 0xc1, 0x90, 0x6e,
	0x55, 0xb2, 0x2f, 0x66, 0x49, 0x74, 0x02, 0x1b, 0x23, 0xac, 0x88, 0xdd, 0x13, 0x19, 0xf9, 0xde,
	0x7e, 0xe3, 0xc0, 0x3b, 0xda, 0xed, 0xda, 0x0a, 0x76, 0xcb, 0x0a, 0x76, 0x2f, 0xca, 0x0a, 0x1e,
	0x37, 0x7f, 0xff, 0x67, 0xaf, 0x11, 0x7a, 0x9a, 0x75, 0x62, 0x49, 0xa8, 0x07, 0xeb, 0x13, 0x22,
	0x24, 0xe5, 0x99, 0xf4, 0x37, 0xf6, 0x97, 0x0f, 0xbc, 0xa3, 0x7b, 0xdd, 0x8a, 0x4b, 0xba, 0x3f,
	0xda, 0x24, 0x19, 0xbd, 0x51, 0xf3, 0x70, 0x46, 0x0b, 0xfe, 0x6e, 0x82, 0xff, 0x36, 0x18, 0xf2,
	0x61, 0xcd, 0x01, 0xfd, 0x86, 0x75, 0x81, 0x9b, 0xa2, 0x33, 0xd8, 0x34, 0xdb, 0xcf, 0x8b, 0x21,
	0xa3, 0x72, 0x4c, 0x46, 0xc6, 0x3e, 0xd7, 0x39, 0xc0, 0x4d, 0xcd, 0xeb, 0x97, 0x34, 0xf4, 0x2d,
	0x6c, 0x24, 0x54, 0x8d, 0x8b, 0x61, 0x14, 0x8f, 0xb1, 0x50, 0xfe, 0x4d, 0x23, 0x53, 0x3f, 0xc6,
	0x99, 0x01, 0x84, 0xb3, 0xd2, 0x9e, 0x73, 0xbb, 0xc7, 0xa7, 0x37, 0x42, 0xcf, 0x92, 0x4f, 0x34,
	0x17, 0x7d, 0x03, 0x1b, 0x63, 0xc2, 0xd2, 0x08, 0x8b, 0x78, 0x4c, 0x27, 0xc4, 0xdf, 0x34, 0x5a,
	0x7e, 0x4d, 0xeb, 0x22, 0xb9, 0xaa, 0xd2, 0x35, 0xbe, 0x67, 0xe1, 0xe8, 0x0c, 0xb6, 0x52, 0x9c,
	0xd1, 0x4b, 0x22, 0x95, 0x9c, 0x69, 0xb4, 0xdf, 0xa9, 0xd1, 0x99, 0x91, 0x4a, 0xa1, 0x3d, 0xf0,
	0x26, 0x98, 0x15, 0x44, 0x46, 0x53, 0x9c, 0x32, 0xff, 0xae, 0xb9, 0x3a, 0xb0, 0xa1, 0x97, 0x38,
	0x65, 0x68, 0x08, 0x6d, 0x41, 0x7e, 0x2e, 0xa8, 0x20, 0xa3, 0x88, 0xe1, 0x21, 0x61, 0xd2, 0xdf,
	0x33, 0xe5, 0xfb, 0xf2, 0x5a, 0xe5, 0xeb, 0x86, 0x8e, 0x7c, 0x6e, 0xb8, 0xa7, 0x99, 0x12, 0xd3,
	0x70, 0x53, 0xd4, 0x82, 0xe8, 0x13, 0x58, 0xbb, 0x64, 0x78, 0xc2, 0x85, 0xf4, 0x0f, 0x8c, 0xf6,
	0x76, 0x4d, 0xfb, 0x89, 0xc9, 0x85, 0x25, 0x66, 0xb7, 0x07, 0xdb, 0x0b, 0x54, 0x51, 0x07, 0x96,
	0x5f, 0x91, 0xa9, 0xab, 0xbe, 0x1e, 0xa2, 0x1d, 0x58, 0x31, 0x27, 0x71, 0xfd, 0xc2, 0x4e, 0xbe,
	0x5a, 0x7a, 0xd8, 0x38, 0xde, 0x86, 0x2d, 0x9a, 0x49, 0x85, 0x19, 0xb3, 0x9f, 0x82, 0xcc, 0x49,
	0x1c, 0xfc, 0xd5, 0x80, 0x55, 0xbb, 0xd6, 0xac, 0xd1, 0x34, 0x2a, 0x8d, 0x66, 0x1f, 0xbc, 0x6a,
	0x6f, 0xb0, 0x9a, 0xd5, 0x10, 0x3a, 0x85, 0x9d, 0xb8, 0x90, 0x8a, 0xa7, 0xf4, 0xca, 0xca, 0x32,
	0x3c, 0x25, 0x42, 0xfa, 0xcb, 0xe6, 0x50, 0xa8, 0x76, 0xa8, 0x73, 0x9d, 0x0a, 0xb7, 0x6b, 0x78,
	0x13, 0x93, 0xe8, 0x09, 0x74, 0xdc, 0x05, 0xe9, 0x46, 0x12, 0x49, 0xa2, 0xa4, 0xdf, 0x34, 0x12,
	0xef, 0xd7, 0x24, 0xc2, 0x39, 0x68, 0x40, 0x54, 0xd8, 0x16, 0xb5, 0xb9, 0x0c, 0xce, 0x60, 0xc5,
	0x28, 0xa2, 0x2f, 0xa0, 0xf5, 0xca, 0xad, 0x63, 0x8f, 0xe4, 0x1d, 0xdd, 0xae, 0x29, 0x3d, 0x2f,
	0xb3, 0x4f, 0x6f, 0x84, 0x73, 0xe8, 0xf1, 0x2a, 0x34, 0xd5, 0x34, 0x27, 0xc1, 0x9f, 0x0d, 0x68,
	0xcd, 0x20, 0xe8, 0x11, 0xac, 0x5a, 0x27, 0x3b, 0xa9, 0x6b, 0x7f, 0x00, 0x8e, 0x86, 0xbe, 0x06,
	0x4f, 0x25, 0x57, 0x33, 0xdb, 0x2e, 0xbd, 0xd3, 0xb6, 0xa0, 0x92, 0xab, 0xd2, 0xb0, 0x1f, 0xc0,
	0x06, 0x9f, 0x10, 0xc1, 0xf0, 0x34, 0xca, 0xb1, 0x1a, 0xbb, 0x96, 0xef, 0xb9, 0x58, 0x1f, 0xab,
	0xf1, 0x31, 0xe8, 0x17, 0xc1, 0x92, 0x83, 0x04, 0xb6, 0x6d, 0x49, 0x4f, 0x78, 0x9a, 0x63, 0x45,
	0x87, 0x94, 0x51, 0x35, 0x45, 0x7d, 0xe8, 0xc4, 0x2e, 0xc0, 0x48, 0x94, 0x63, 0x2a, 0xa4, 0xdf,
	0x58, 0xd0, 0x95, 0x4e, 0x66, 0x20, 0xab, 0xf2, 0x82, 0xc8, 0x71, 0x1f, 0x53, 0x11, 0xb6, 0xe7,
	0x74, 0x3d, 0x97, 0xc1, 0x23, 0xf0, 0x42, 0x22, 0x79, 0x21, 0x62, 0x12, 0x92, 0xcb, 0x85, 0x06,
	0xba, 0x03, 0x2d, 0xfd, 0x2b, 0x73, 0x1c, 0x97, 0x96, 0x9c, 0x07, 0x82, 0x02, 0xfc, 0xb7, 0xad,
	0x86, 0xee, 0xc3, 0xaa, 0x35, 0xbf, 0xbb, 0xf2, 0x85, 0xdf, 0x87, 0x83, 0xa0, 0x8f, 0xa1, 0x99,
	0x12, 0x39, 0x5e, 0x78, 0xaf, 0x95, 0x2d, 0x86, 0x06, 0x15, 0xbc, 0x84, 0xcd, 0xba, 0x8f, 0xd0,
	0x19, 0x74, 0x74, 0x26, 0xaa, 0xd8, 0xc9, 0x2d, 0x7b, 0xa7, 0xa6, 0xa5, 0x77, 0x57, 0xa1, 0x86,
	0xed, 0xb4, 0x1e, 0x08, 0x7e, 0x85, 0xf6, 0x1b, 0x18, 0x74, 0x04, 0x2d, 0xa3, 0xad, 0x6d, 0x65,
	0x44, 0x37, 0x8f, 0x6e, 0xfd, 0x4f, 0xf4, 0x62, 0x9a, 0x93, 0x70, 0x3d, 0x75, 0x23, 0xf4, 0xb0,
	0xf2, 0x72, 0x2c, 0x2d, 0xd8, 0x47, 0x8f, 0x31, 0xfe, 0x0b, 0x19, 0xb9, 0x0e, 0x24, 0x2b, 0x0f,
	0x46, 0x0e, 0xfe, 0xdb, 0xec, 0xa8, 0xbb, 0x05, 0x17, 0x49, 0xd9, 0x2d, 0xb8, 0x48, 0x74, 0xc9,
	0xf4, 0x93, 0x5c, 0xfe, 0xb9, 0xd0, 0x63, 0x8d, 0x12, 0xe4, 0xd2, 0x99, 0x4c, 0x0f, 0x75, 0x11,
	0x47, 0x54, 0x90, 0x58, 0x8b, 0xb9, 0xff, 0x12, 0xf3, 0x40, 0xb0, 0x07, 0x5e, 0xc5, 0xba, 0x9a,
	0xae, 0x1f, 0x7c, 0xb7, 0x48, 0x21, 0x58, 0x30, 0x80, 0xf6, 0x1b, 0xfb, 0xd5, 0x2d, 0x38, 0xa5,
	0x59, 0x54, 0xbe, 0x5e, 0x76, 0x79, 0x48, 0x69, 0xe6, 0x10, 0x06, 0x80, 0x5f, 0xcf, 0x00, 0xcb,
	0x0e, 0x80, 0x5f, 0x3b, 0xc0, 0x47, 0x9f, 0xc1, 0x7a, 0x79, 0x6f, 0xa8, 0x05, 0x2b, 0xcf, 0x06,
	0x17, 0xcf, 0xbe, 0xef, 0xdc, 0x40, 0x1e, 0xac, 0x9d, 0x3f, 0xfb, 0xee, 0xf9, 0x69, 0xf8, 0xb8,
	0xd3, 0x40, 0x1d, 0xd8, 0xe8, 0xfd, 0x34, 0x88, 0x7a, 0xfd, 0x7e, 0xf4, 0xe2, 0x74, 0xf0, 0xb4,
	0xb3, 0x74, 0xdc, 0xfc, 0xe3, 0xdf, 0xbb, 0x8d, 0xe1, 0xaa, 0x79, 0xfd, 0x3e, 0xfd, 0x2f, 0x00,
	0x00, 0xff, 0xff, 0xee, 0xef, 0x59, 0xca, 0xca, 0x09, 0x00, 0x00,
}

func (this *ApplicationSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationSpec)
	if !ok {
		that2, ok := that.(ApplicationSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.LogoUrl != that1.LogoUrl {
		return false
	}
	if this.ShortDescription != that1.ShortDescription {
		return false
	}
	if this.LongDescription != that1.LongDescription {
		return false
	}
	if this.DocumentationUrl != that1.DocumentationUrl {
		return false
	}
	if this.RepositoryUrl != that1.RepositoryUrl {
		return false
	}
	if this.ApplicationCreator != that1.ApplicationCreator {
		return false
	}
	if this.ApplicationProvider != that1.ApplicationProvider {
		return false
	}
	if this.ApplicationMaintainer != that1.ApplicationMaintainer {
		return false
	}
	if that1.DateCreated == nil {
		if this.DateCreated != nil {
			return false
		}
	} else if !this.DateCreated.Equal(*that1.DateCreated) {
		return false
	}
	if len(this.Versions) != len(that1.Versions) {
		return false
	}
	for i := range this.Versions {
		if !this.Versions[i].Equal(that1.Versions[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if that1.DatePublished == nil {
		if this.DatePublished != nil {
			return false
		}
	} else if !this.DatePublished.Equal(*that1.DatePublished) {
		return false
	}
	if that1.InstallationSpec == nil {
		if this.InstallationSpec != nil {
			return false
		}
	} else if this.InstallationSpec == nil {
		return false
	} else if !this.InstallationSpec.Equal(that1.InstallationSpec) {
		return false
	}
	if this.ValuesYaml != that1.ValuesYaml {
		return false
	}
	if len(this.RequiredLabels) != len(that1.RequiredLabels) {
		return false
	}
	for i := range this.RequiredLabels {
		if this.RequiredLabels[i] != that1.RequiredLabels[i] {
			return false
		}
	}
	if len(this.Flavors) != len(that1.Flavors) {
		return false
	}
	for i := range this.Flavors {
		if !this.Flavors[i].Equal(that1.Flavors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_GithubChart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_GithubChart)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_GithubChart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GithubChart.Equal(that1.GithubChart) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_HelmArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_HelmArchive)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_HelmArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HelmArchive.Equal(that1.HelmArchive) {
		return false
	}
	return true
}
func (this *VersionedApplicationSpec_ManifestsArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedApplicationSpec_ManifestsArchive)
	if !ok {
		that2, ok := that.(VersionedApplicationSpec_ManifestsArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManifestsArchive.Equal(that1.ManifestsArchive) {
		return false
	}
	return true
}
func (this *Flavor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flavor)
	if !ok {
		that2, ok := that.(Flavor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.CustomizationLayers) != len(that1.CustomizationLayers) {
		return false
	}
	for i := range this.CustomizationLayers {
		if !this.CustomizationLayers[i].Equal(that1.CustomizationLayers[i]) {
			return false
		}
	}
	if len(this.RequirementSets) != len(that1.RequirementSets) {
		return false
	}
	for i := range this.RequirementSets {
		if !this.RequirementSets[i].Equal(that1.RequirementSets[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Layer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer)
	if !ok {
		that2, ok := that.(Layer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Layer_Kustomize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer_Kustomize)
	if !ok {
		that2, ok := that.(Layer_Kustomize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Kustomize.Equal(that1.Kustomize) {
		return false
	}
	return true
}
func (this *Kustomize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize)
	if !ok {
		that2, ok := that.(Kustomize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Location == nil {
		if this.Location != nil {
			return false
		}
	} else if this.Location == nil {
		return false
	} else if !this.Location.Equal(that1.Location) {
		return false
	}
	if this.OverlayPath != that1.OverlayPath {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Kustomize_Github) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize_Github)
	if !ok {
		that2, ok := that.(Kustomize_Github)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Github.Equal(that1.Github) {
		return false
	}
	return true
}
func (this *Kustomize_TgzArchive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kustomize_TgzArchive)
	if !ok {
		that2, ok := that.(Kustomize_TgzArchive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TgzArchive.Equal(that1.TgzArchive) {
		return false
	}
	return true
}
func (this *FlavorCompatibility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlavorCompatibility)
	if !ok {
		that2, ok := that.(FlavorCompatibility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CompatiblePairs) != len(that1.CompatiblePairs) {
		return false
	}
	for i := range this.CompatiblePairs {
		if !this.CompatiblePairs[i].Equal(that1.CompatiblePairs[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ResourceRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResourceRef)
	if !ok {
		that2, ok := that.(ResourceRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CompatibleFlavorMeshPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompatibleFlavorMeshPair)
	if !ok {
		that2, ok := that.(CompatibleFlavorMeshPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Flavor.Equal(that1.Flavor) {
		return false
	}
	if !this.Mesh.Equal(that1.Mesh) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RequirementSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequirementSet)
	if !ok {
		that2, ok := that.(RequirementSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MeshRequirement.Equal(that1.MeshRequirement) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MeshRequirement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeshRequirement)
	if !ok {
		that2, ok := that.(MeshRequirement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MeshType != that1.MeshType {
		return false
	}
	if !this.Versions.Equal(that1.Versions) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GithubRepositoryLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GithubRepositoryLocation)
	if !ok {
		that2, ok := that.(GithubRepositoryLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Org != that1.Org {
		return false
	}
	if this.Repo != that1.Repo {
		return false
	}
	if this.Ref != that1.Ref {
		return false
	}
	if this.Directory != that1.Directory {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TgzLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TgzLocation)
	if !ok {
		that2, ok := that.(TgzLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AllowedVersions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVersions)
	if !ok {
		that2, ok := that.(AllowedVersions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinVersion != that1.MinVersion {
		return false
	}
	if this.MaxVersion != that1.MaxVersion {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
